# app.py
import os
from datetime import datetime
from flask import Flask, request, jsonify, render_template
from flask_cors import CORS
from flask_sqlalchemy import SQLAlchemy
from dotenv import load_dotenv
import google.generativeai as genai
import gspread
from oauth2client.service_account import ServiceAccountCredentials
import json
import re 


load_dotenv()
app = Flask(__name__, instance_relative_config=True, template_folder='templates')
CORS(app)

app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
print(f"--- DATABASE URI IN USE: {app.config['SQLALCHEMY_DATABASE_URI']} ---")

class Response(db.Model):
    __tablename__ = 'responses'
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(db.String(100))
    question = db.Column(db.Text, nullable=False)
    student_answer = db.Column(db.Text, nullable=False)
    ai_feedback = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    rating = db.Column(db.Integer)
    feedback_comment = db.Column(db.Text)
    is_ai_generated = db.Column(db.Boolean, default=False, nullable=False) 
    performance_grade = db.Column(db.String(50))

with app.app_context():
    db.create_all()

# --- Key Information ---
# Warning: For security reasons, API keys should not be hard-coded.
# In a real deployment, use environment variables or a secure key management service.
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
try:
    genai.configure(api_key=GEMINI_API_KEY)
    model = genai.GenerativeModel('gemini-1.5-flash')
except Exception as e:
    print(f"API configuration failed: {e}")
    model = None

def get_generic_feedback(prompt_id, student_answer):
    if not model:
        return "AI model failed to load."
    
    try:
        # 根据prompt_id，从prompts文件夹读取对应的指令文件
        prompt_path = os.path.join('prompts', f'{prompt_id}.txt')
        with open(prompt_path, 'r', encoding='utf-8') as f:
            system_prompt = f.read()
        
        # 构建最终的Prompt并调用API
        full_prompt = f"{system_prompt}\n\nThe student's answer is:\n\"{student_answer}\""
        response = model.generate_content(full_prompt)
        return response.text
    except FileNotFoundError:
        print(f"Error: Prompt file not found at {prompt_path}")
        return "Error: The requested prompt (question) could not be found."
    except Exception as e:
        print(f"Error calling Gemini API: {e}")
        return "Sorry, an error occurred while getting feedback from the AI."


def append_to_google_sheet(row_data):
    try:
        # define the scope for Google Sheets and Drive API
        scope = ["https://spreadsheets.google.com/feeds", 'https://www.googleapis.com/auth/drive']

        # use service account credentials to authorize gspread
        creds = ServiceAccountCredentials.from_json_keyfile_name("google_credentials.json", scope)
        client = gspread.authorize(creds)

        sheet = client.open("AI Biostats Feedback").sheet1

        # add a new row with the provided data
        sheet.append_row(row_data)
        print("Successfully appended a row to Google Sheet.")
    except Exception as e:
        print(f"Google Sheet write error: {e}")

def update_gsheet_row(response_id, full_row_data):
    """Finds a row by its ID and updates it with new data."""
    try:
        scope = ["https://spreadsheets.google.com/feeds", 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_name("google_credentials.json", scope)
        client = gspread.authorize(creds)
        sheet = client.open("AI Biostats Feedback").sheet1

        # Find the cell that contains the unique response ID
        # Assumes the 'id' is in the first column of your Google Sheet
        cell = sheet.find(str(response_id), in_column=1)
        if cell:
            # gspread's update method takes a range and a list of lists.
            # Example: update('A5:H5', [[ ... values ... ]])
            start_col = gspread.utils.rowcol_to_a1(cell.row, 1)[0] # e.g., 'A'
            end_col = gspread.utils.rowcol_to_a1(cell.row, len(full_row_data))[0] # e.g., 'H'
            sheet.update(f'{start_col}{cell.row}:{end_col}{cell.row}', [full_row_data])
            print(f"Successfully updated row {cell.row} in Google Sheet.")
        else:
            print(f"Warning: Could not find response_id {response_id} in Google Sheet to update.")
    except Exception as e:
        print(f"Google Sheet update error: {e}")
def clean_json_from_ai_response(ai_text):
    """
    Extracts a JSON object from a string that might be wrapped in markdown.
    """
    match = re.search(r'```(json)?\s*({.*?})\s*```', ai_text, re.DOTALL)
    if match:
        return match.group(2)
    return ai_text.strip()
def is_answer_ai_generated(student_answer):
    """Uses AI to flag if an answer is likely AI-generated by asking for a JSON response."""
    if not model:
        return False # Fail safe
    
    try:
        # --- 这是新的、更可靠的Prompt ---
        prompt = f"""
        You are an expert text classifier. Your task is to determine if the following student's response was likely written by an AI or a human.
        You must respond with only a valid JSON object containing a single key: "classification".
        The value for "classification" must be one of two strings: "AI" or "Human".

        Example Response:
        {{
          "classification": "AI"
        }}

        Now, analyze the following text:
        ---
        Student's text: "{student_answer}"
        ---
        """
        
        response = model.generate_content(prompt)

        # --- 这是新的、更可靠的解析逻辑 ---
        # 1. 尝试将AI的文本回复解析为JSON对象
        cleaned_text = clean_json_from_ai_response(response.text)
        result_json = json.loads(cleaned_text)
        # 2. 从JSON对象中获取分类结果
        classification = result_json.get("classification", "").lower()
        
        # 3. 检查分类结果并返回布尔值
        if classification == "ai":
            return True
        else:
            return False
            
    except Exception as e:
        # 如果AI没有返回有效的JSON，或者解析失败，都视为错误
        print(f"AI detection error or invalid JSON response: {e}")
        print(f"Original AI response text: {response.text}")
        return False # 如果检测失败，默认不是AI生成的
def get_feedback_and_grade(prompt_id, student_answer):
    """
    Gets both feedback and a performance grade from the AI using a structured JSON response.
    """
    if not model:
        return "AI model failed to load.", "N/A"

    try:
        prompt_path = os.path.join('prompts', f'{prompt_id}.txt')
        with open(prompt_path, 'r', encoding='utf-8') as f:
            system_prompt = f.read()

        # 新的、要求返回JSON的Prompt
        full_prompt = f"""
        {system_prompt}

        ---
        TASK:
        Based on the rubric and guidelines above, analyze the following student's answer.
        You MUST respond with only a valid JSON object containing two keys:
        1.  "grade": A string classifying the student's performance based on the rubric (e.g., "Great answer", "Good answer", "Thinking start", "Too superficial", "Misunderstood / incorrect").
        2.  "feedback": A string containing the helpful, warm, and encouraging feedback for the student.

        Student's answer: "{student_answer}"
        """

        response = model.generate_content(full_prompt)
        cleaned_text = clean_json_from_ai_response(response.text)
        result_json = json.loads(cleaned_text)

        grade = result_json.get("grade", "N/A")
        feedback = result_json.get("feedback", "Could not generate feedback.")

        return feedback, grade

    except Exception as e:
        print(f"Error getting feedback and grade: {e}")
        return "Sorry, an error occurred while getting feedback.", "Error"
@app.route('/api/evaluate', methods=['POST'])
def handle_evaluation():
    data = request.get_json()
    student_answer = data.get('answer')
    student_id = data.get('student_id', 'anonymous')
    prompt_id = data.get('prompt_id')

    if not prompt_id:
        return jsonify({'error': 'A prompt_id must be provided.'}), 400
    
    is_ai = is_answer_ai_generated(student_answer)
    print(f"AI detection result for new answer: {is_ai}")
    
    # 调用新的评分函数，它会同时返回feedback和grade
    ai_feedback, performance_grade = get_feedback_and_grade(prompt_id, student_answer)

    new_response = Response(
        student_id=student_id,
        question=prompt_id,
        student_answer=student_answer,
        ai_feedback=ai_feedback,
        timestamp=datetime.now(),
        is_ai_generated=is_ai,
        performance_grade=performance_grade # <-- 将获取到的评级存入数据库
    )
    db.session.add(new_response)
    db.session.commit()
    return jsonify({'feedback': ai_feedback, 'response_id': new_response.id})
# --- Add the new endpoint for receiving ratings ---
@app.route('/api/rate-feedback', methods=['POST'])
def rate_feedback():
    data = request.get_json()
    response_id = data.get('response_id')
    rating = data.get('rating')
    comment = data.get('comment', '')

    response_to_update = Response.query.get(response_id)
    if response_to_update:
        response_to_update.rating = rating
        response_to_update.feedback_comment = comment
        db.session.commit()

        full_updated_row = [
            response_to_update.id, str(response_to_update.timestamp), response_to_update.student_id,
            response_to_update.question, response_to_update.student_answer, response_to_update.ai_feedback,
            response_to_update.rating, response_to_update.feedback_comment
        ]
        update_gsheet_row(response_id, [str(item) for item in full_updated_row])
        
        return jsonify({'status': 'success'}), 200
    
    return jsonify({'status': 'error', 'message': 'Response not found'}), 404

@app.route('/dashboard')
def dashboard():
    return render_template('dashboard.html')

@app.route('/api/get-all-feedback', methods=['GET'])
def get_all_feedback():
    responses = Response.query.order_by(Response.timestamp.desc()).all()
    output = []
    for r in responses:
        output.append({
            'id': r.id,
            'student_id': r.student_id,
            'question': r.question,
            'student_answer': r.student_answer,
            'ai_feedback': r.ai_feedback,
            'timestamp': r.timestamp.isoformat(),
            'rating': r.rating,
            'feedback_comment': r.feedback_comment,
            'is_ai_generated': r.is_ai_generated,
            'performance_grade': r.performance_grade # <-- 新增这一行
        })
    return jsonify(output)

@app.route('/api/get-summary', methods=['GET'])
def get_summary():
    """API endpoint to generate an AI-powered summary of all answers."""
    # 使用SQLAlchemy查询
    responses = Response.query.filter(
        Response.student_answer != '',
        Response.is_ai_generated == False
    ).all()
    if not responses:
        return jsonify({'summary': 'Not enough data to generate a summary.'})

    all_answers_text = "\n\n---\n\n".join([res.student_answer for res in responses])

    summary_prompt = f"""
        You are an expert teaching assistant analyzing student responses for a data visualization critique.
        Based on the following collection of student answers, please provide a concise, high-level summary for the instructor in markdown format.

        Address these key points:
        1.  **Overall Performance:** Briefly categorize the class's overall performance (e.g., Excellent, Good, Fair, Poor) and why.
        2.  **Common Points of Confusion:** List 2-3 topics or concepts that students commonly misunderstood or failed to mention.
        3.  **Creative/Insightful Answers:** Highlight one or two specific, creative, or insightful answers that stood out. Quote a small, impactful part of the answer.

        Here are the student answers to analyze:
        ---
        {all_answers_text}
        ---
        """
    try:
        summary_response = model.generate_content(summary_prompt)
        return jsonify({'summary': summary_response.text})
    except Exception as e:
        print(f"Summary generation error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/clear-all-feedback', methods=['POST'])
def clear_all_feedback():
    """
    Deletes all records from the 'responses' table and clears the Google Sheet.
    """
    try:
        # --- 1. Clear the PostgreSQL Database Table ---
        # This deletes all rows from the 'responses' table but keeps the table itself.
        db.session.query(Response).delete()
        db.session.commit()
        print("Successfully cleared all rows from the 'responses' table.")

        # --- 2. Clear the Google Sheet ---
        scope = ["https://spreadsheets.google.com/feeds", 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_name("google_credentials.json", scope)
        client = gspread.authorize(creds)
        sheet = client.open("AI Biostats Feedback").sheet1
        
        # Deletes all rows except for the first one (the header)
        sheet.clear() 
        # Optional: Re-add the header row after clearing
        header = ["id", "timestamp", "student_id", "question", "student_answer", "ai_feedback", "rating", "feedback_comment"]
        sheet.append_row(header)
        print("Successfully cleared the Google Sheet.")
        
        return jsonify({'status': 'success', 'message': 'All feedback data has been cleared.'}), 200

    except Exception as e:
        db.session.rollback()
        print(f"Error clearing data: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500
@app.route('/api/question-details/<string:prompt_id>')
def get_question_details(prompt_id):
    try:
        with open('questions.json', 'r', encoding='utf-8') as f:
            questions = json.load(f)

        question_data = questions.get(prompt_id)

        if question_data:
            return jsonify(question_data)
        else:
            return jsonify({'error': 'Question details not found'}), 404
    except Exception as e:
        print(f"Error reading questions.json: {e}")
        return jsonify({'error': 'Internal server error'}), 500

if __name__ == '__main__':
    app.run(debug=True, port=5001, host='0.0.0.0')